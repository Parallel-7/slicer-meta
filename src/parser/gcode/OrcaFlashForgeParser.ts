import * as fs from 'fs';
import { SlicerMeta } from '../../SlicerMeta';
import { SlicerFileMeta } from '../../SlicerFileMeta';
import { SlicerType } from '../../SlicerType';
import { ParserHelper } from '../ParserHelper';

interface OrcaFFParseResult {
    slicerMeta: SlicerMeta;
    fileMeta: SlicerFileMeta;
}

export class OrcaFlashForgeParser {

    /**
     * Parses a G-code file generated by Orca-FlashForge from a file path.
     * @param filePath Path to the G-code file.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     * @throws Error if the file cannot be read.
     */
    public static parse(filePath: string): OrcaFFParseResult {
        try {
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            return OrcaFlashForgeParser.parseContent(fileContent);
        } catch (error) {
            console.error(`Error reading or parsing OrcaFF file ${filePath}:`, error);
            throw new Error(`Failed to read or parse OrcaFF file: ${filePath}`);
        }
    }

    /**
     * Parses G-code content generated by Orca-FlashForge from a string or Buffer.
     * @param content The G-code content as a string or Buffer.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    public static parseFromContent(content: string | Buffer): OrcaFFParseResult {
        const contentString = Buffer.isBuffer(content) ? content.toString('utf-8') : content;
        return OrcaFlashForgeParser.parseContent(contentString);
    }

    /**
     * Internal method to parse G-code content string.
     * @param contentString The G-code content as a string.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    private static parseContent(contentString: string): OrcaFFParseResult {
        const slicerMeta = new SlicerMeta();
        const fileMeta = new SlicerFileMeta();
        fileMeta.sliceSoft = SlicerType.OrcaFF; // Set slicer type early

        let inHeaderBlock = false;
        let inThumbnailBlock = false;
        let inThumbnailData = false;
        let inConfigBlock = false;
        let thumbnailDataBase64 = '';

        const lines = contentString.split(/\r?\n/);

        for (const rawLine of lines) {
            const line = rawLine.trim();

            // Block delimiters
            if (line.startsWith('; HEADER_BLOCK_START')) { inHeaderBlock = true; continue; }
            if (line.startsWith('; HEADER_BLOCK_END')) { inHeaderBlock = false; continue; }
            if (line.startsWith('; THUMBNAIL_BLOCK_START')) { inThumbnailBlock = true; continue; }
            if (line.startsWith('; THUMBNAIL_BLOCK_END')) { inThumbnailBlock = false; continue; }
            if (line.startsWith('; CONFIG_BLOCK_START')) { inConfigBlock = true; continue; }
            if (line.startsWith('; CONFIG_BLOCK_END')) { inConfigBlock = false; continue; }


            // --- Block Processing ---
            if (inHeaderBlock) {
                OrcaFlashForgeParser.parseHeaderLine(line, slicerMeta);
            } else if (inThumbnailBlock) {
                // Check for thumbnail data start/end tags
                if (line.toLowerCase().startsWith('; thumbnail begin')) {
                    inThumbnailData = true;
                    // Extract dimensions if present (e.g., ; thumbnail begin 200x200 12345)
                    // We don't strictly need them for storage, but could parse if needed.
                    continue;
                }
                if (line.toLowerCase().startsWith('; thumbnail end')) {
                    inThumbnailData = false;
                    // Process collected thumbnail data
                    OrcaFlashForgeParser.processThumbnailData(thumbnailDataBase64, fileMeta);
                    thumbnailDataBase64 = ''; // Reset for next potential thumbnail
                    continue;
                }

                // Accumulate Base64 data if inside the thumbnail data section
                if (inThumbnailData) {
                    const base64Line = line.replace(/^;\s*/, ''); // Remove leading "; "
                    thumbnailDataBase64 += base64Line;
                }
            } else if (inConfigBlock) {
                OrcaFlashForgeParser.parseConfigLine(line, fileMeta);
            } else if (line.startsWith(';')) {
                // Process general comments outside specific blocks (like ETA, filament usage)
                OrcaFlashForgeParser.parseAdditionalData(line, fileMeta, slicerMeta);
            }
        } // End of line loop

        // Final check in case thumbnail block ended without an explicit '; thumbnail end' (unlikely but safe)
        if (thumbnailDataBase64) {
            console.warn("Thumbnail data might be incomplete (no explicit '; thumbnail end' found).");
            OrcaFlashForgeParser.processThumbnailData(thumbnailDataBase64, fileMeta);
        }


        return { slicerMeta, fileMeta };
    }

    /**
     * Parses a line within the HEADER_BLOCK.
     * @param line The comment line.
     * @param meta The SlicerMeta object.
     */
    private static parseHeaderLine(line: string, meta: SlicerMeta): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim(); // Remove leading "; "

        if (cleanedLine.startsWith('generated by')) {
            meta.fromGeneratedByString(SlicerType.OrcaFF, line); // Pass original line with ';' for parsing context
        } else if (cleanedLine.startsWith('model printing time')) {
            // Legacy ETA format, handled by parseAdditionalData now
            // meta.setEta(cleanedLine);
        }
        // Other header-specific parsing if needed
    }

    /**
     * Parses a line within the CONFIG_BLOCK.
     * @param line The comment line.
     * @param fileMeta The SlicerFileMeta object.
     */
    private static parseConfigLine(line: string, fileMeta: SlicerFileMeta): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim();
        const equalsIndex = cleanedLine.indexOf('=');

        if (equalsIndex > -1) {
            const key = cleanedLine.substring(0, equalsIndex).trim();
            const value = cleanedLine.substring(equalsIndex + 1).trim().replace(/^"|"$/g, ''); // Remove surrounding quotes if any

            switch (key) {
                case 'filament_type':
                    if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const types = JSON.parse(value);
                            fileMeta.filamentType = Array.isArray(types) ? types.join(', ') : value;
                        } catch {
                            fileMeta.filamentType = value;
                        }
                    } else {
                        fileMeta.filamentType = value;
                    }
                    break;
                case 'printer_model':
                    fileMeta.printerModel = value;
                    break;
                // Add other config keys if needed (e.g., layer_height, nozzle_diameter)
            }
        }
    }

    /**
     * Parses additional metadata lines (typically outside specific blocks).
     * @param line The comment line.
     * @param fileMeta The SlicerFileMeta object.
     * @param slicerMeta The SlicerMeta object.
     */
    private static parseAdditionalData(line: string, fileMeta: SlicerFileMeta, slicerMeta: SlicerMeta): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim();
        const equalsIndex = cleanedLine.indexOf('=');

        // Check for ETA line first (doesn't always follow key=value)
        if (cleanedLine.includes('estimated printing time') || cleanedLine.includes('model printing time')) {
            slicerMeta.setEta(cleanedLine); // Use the dedicated method in SlicerMeta
            return; // Don't process further as key=value
        }

        // Process standard key = value lines
        if (equalsIndex > -1) {
            const key = cleanedLine.substring(0, equalsIndex).trim();
            const value = cleanedLine.substring(equalsIndex + 1).trim();

            switch (key) {
                case 'filament used [mm]':
                    if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const values = JSON.parse(value);
                            // Sum if multiple extruders reported
                            fileMeta.filamentUsedMM = Array.isArray(values) ? values.reduce((sum: number, val: string) => sum + ParserHelper.parseFloatOrDefault(val), 0) : ParserHelper.parseFloatOrDefault(value);
                        } catch {
                            fileMeta.filamentUsedMM = ParserHelper.parseFloatOrDefault(value); // Fallback
                        }
                    } else {
                        fileMeta.filamentUsedMM = ParserHelper.parseFloatOrDefault(value);
                    }
                    break;
                case 'filament used [g]':
                    if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const values = JSON.parse(value);
                            // Sum if multiple extruders reported
                            fileMeta.filamentUsedG = Array.isArray(values) ? values.reduce((sum: number, val: string) => sum + ParserHelper.parseFloatOrDefault(val), 0) : ParserHelper.parseFloatOrDefault(value);
                        } catch {
                            fileMeta.filamentUsedG = ParserHelper.parseFloatOrDefault(value); // Fallback
                        }
                    } else {
                        fileMeta.filamentUsedG = ParserHelper.parseFloatOrDefault(value);
                    }
                    break;
                // Add other relevant keys found outside blocks
            }
        }
    }

    /**
     * Processes the accumulated base64 thumbnail data.
     * Currently just stores it in fileMeta.
     * @param base64Data The full base64 encoded string.
     * @param fileMeta The SlicerFileMeta object.
     */
    private static processThumbnailData(base64Data: string, fileMeta: SlicerFileMeta): void {
        if (base64Data && base64Data.length > 0) {
            if (/^[A-Za-z0-9+/]*=?=?$/.test(base64Data)) {
                fileMeta.thumbnail = `data:image/png;base64,${base64Data}`;
            } else {
                console.warn("Collected thumbnail data does not appear to be valid Base64.");
                fileMeta.thumbnail = null;
            }
        } else {
            fileMeta.thumbnail = null;
        }
    }
}