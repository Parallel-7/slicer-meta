import * as fs from 'fs';
import { SlicerMeta } from '../../SlicerMeta';
import { SlicerFileMeta } from '../../SlicerFileMeta';
import { SlicerType } from '../../SlicerType';
import { ParserHelper } from '../ParserHelper';

interface OrcaFFParseResult {
    slicerMeta: SlicerMeta;
    fileMeta: SlicerFileMeta;
}

export class OrcaFlashForgeParser {

    /**
     * Parses a G-code file generated by Orca-FlashForge from a file path.
     * @param filePath Path to the G-code file.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     * @throws Error if the file cannot be read.
     */
    public static parse(filePath: string): OrcaFFParseResult {
        try {
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            return OrcaFlashForgeParser.parseContent(fileContent);
        } catch (error) {
            console.error(`Error reading or parsing OrcaFF file ${filePath}:`, error);
            throw new Error(`Failed to read or parse OrcaFF file: ${filePath}`);
        }
    }

    /**
     * Parses G-code content generated by Orca-FlashForge from a string or Buffer.
     * @param content The G-code content as a string or Buffer.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    public static parseFromContent(content: string | Buffer): OrcaFFParseResult {
        const contentString = Buffer.isBuffer(content) ? content.toString('utf-8') : content;
        return OrcaFlashForgeParser.parseContent(contentString);
    }

    /**
     * Internal method to parse G-code content string.
     * @param contentString The G-code content as a string.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    private static parseContent(contentString: string): OrcaFFParseResult {
        const slicerMeta = new SlicerMeta();
        const fileMeta = new SlicerFileMeta();
        fileMeta.sliceSoft = SlicerType.OrcaFF; // Set slicer type early

        let inHeaderBlock = false;
        let inThumbnailBlock = false;
        let inThumbnailData = false;
        let inConfigBlock = false;
        let thumbnailDataBase64 = '';

        // Temporary storage for parallel arrays to correlate filament data
        let filamentTypeArray: string[] = [];
        let filamentUsedMMArray: number[] = [];
        let filamentUsedGArray: number[] = [];
        let filamentColorArray: string[] = [];

        const lines = contentString.split(/\r?\n/);

        for (const rawLine of lines) {
            const line = rawLine.trim();

            // Block delimiters
            if (line.startsWith('; HEADER_BLOCK_START')) { inHeaderBlock = true; continue; }
            if (line.startsWith('; HEADER_BLOCK_END')) { inHeaderBlock = false; continue; }
            if (line.startsWith('; THUMBNAIL_BLOCK_START')) { inThumbnailBlock = true; continue; }
            if (line.startsWith('; THUMBNAIL_BLOCK_END')) { inThumbnailBlock = false; continue; }
            if (line.startsWith('; CONFIG_BLOCK_START')) { inConfigBlock = true; continue; }
            if (line.startsWith('; CONFIG_BLOCK_END')) { inConfigBlock = false; continue; }


            // --- Block Processing ---
            if (inHeaderBlock) {
                OrcaFlashForgeParser.parseHeaderLine(line, slicerMeta);
            } else if (inThumbnailBlock) {
                // Check for thumbnail data start/end tags
                if (line.toLowerCase().startsWith('; thumbnail begin')) {
                    inThumbnailData = true;
                    // Extract dimensions if present (e.g., ; thumbnail begin 200x200 12345)
                    // We don't strictly need them for storage, but could parse if needed.
                    continue;
                }
                if (line.toLowerCase().startsWith('; thumbnail end')) {
                    inThumbnailData = false;
                    // Process collected thumbnail data
                    OrcaFlashForgeParser.processThumbnailData(thumbnailDataBase64, fileMeta);
                    thumbnailDataBase64 = ''; // Reset for next potential thumbnail
                    continue;
                }

                // Accumulate Base64 data if inside the thumbnail data section
                if (inThumbnailData) {
                    const base64Line = line.replace(/^;\s*/, ''); // Remove leading "; "
                    thumbnailDataBase64 += base64Line;
                }
            } else if (inConfigBlock) {
                OrcaFlashForgeParser.parseConfigLine(line, fileMeta, filamentTypeArray, filamentColorArray);
            } else if (line.startsWith(';')) {
                // Process general comments outside specific blocks (like ETA, filament usage)
                OrcaFlashForgeParser.parseAdditionalData(line, fileMeta, slicerMeta, filamentUsedMMArray, filamentUsedGArray);
            }
        } // End of line loop

        // Final check in case thumbnail block ended without an explicit '; thumbnail end' (unlikely but safe)
        if (thumbnailDataBase64) {
            console.warn("Thumbnail data might be incomplete (no explicit '; thumbnail end' found).");
            OrcaFlashForgeParser.processThumbnailData(thumbnailDataBase64, fileMeta);
        }

        // Post-process filament data: correlate parallel arrays and filter unused filaments
        if (filamentTypeArray.length > 0) {
            const filaments: any[] = [];
            const usedTypes: string[] = [];

            for (let i = 0; i < filamentTypeArray.length; i++) {
                const usedMM = filamentUsedMMArray[i] || 0;
                const usedG = filamentUsedGArray[i] || 0;

                // Only include filaments that are actually used (non-zero usage)
                if (usedMM > 0 || usedG > 0) {
                    filaments.push({
                        id: i.toString(),
                        type: filamentTypeArray[i],
                        color: filamentColorArray[i] || null,
                        usedM: usedMM.toFixed(2),
                        usedG: usedG.toFixed(2)
                    });
                    usedTypes.push(filamentTypeArray[i]);
                }
            }

            // Set the detailed filaments array
            fileMeta.filaments = filaments;

            // Update filamentType string to only show used filaments
            fileMeta.filamentType = usedTypes.length > 0
                ? usedTypes.join(';')
                : "Unknown";
        }

        return { slicerMeta, fileMeta };
    }

    /**
     * Parses a line within the HEADER_BLOCK.
     * @param line The comment line.
     * @param meta The SlicerMeta object.
     */
    private static parseHeaderLine(line: string, meta: SlicerMeta): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim(); // Remove leading "; "

        if (cleanedLine.startsWith('generated by')) {
            meta.fromGeneratedByString(SlicerType.OrcaFF, line); // Pass original line with ';' for parsing context
        } else if (cleanedLine.startsWith('model printing time')) {
            // Legacy ETA format, handled by parseAdditionalData now
            // meta.setEta(cleanedLine);
        }
        // Other header-specific parsing if needed
    }

    /**
     * Parses a line within the CONFIG_BLOCK.
     * @param line The comment line.
     * @param fileMeta The SlicerFileMeta object.
     * @param filamentTypeArray Array to store filament types.
     * @param filamentColorArray Array to store filament colors.
     */
    private static parseConfigLine(
        line: string,
        fileMeta: SlicerFileMeta,
        filamentTypeArray: string[],
        filamentColorArray: string[]
    ): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim();
        const equalsIndex = cleanedLine.indexOf('=');

        if (equalsIndex > -1) {
            const key = cleanedLine.substring(0, equalsIndex).trim();
            const value = cleanedLine.substring(equalsIndex + 1).trim().replace(/^"|"$/g, ''); // Remove surrounding quotes if any

            switch (key) {
                case 'filament_type':
                    // Store as array for later correlation with usage data
                    if (value.includes(';')) {
                        filamentTypeArray.push(...value.split(';').map(t => t.trim()));
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const types = JSON.parse(value);
                            if (Array.isArray(types)) {
                                filamentTypeArray.push(...types);
                            } else {
                                filamentTypeArray.push(value);
                            }
                        } catch {
                            filamentTypeArray.push(value);
                        }
                    } else {
                        filamentTypeArray.push(value);
                    }
                    // Don't set fileMeta.filamentType yet - will filter later
                    break;
                case 'filament_colour':
                case 'filament_color':
                    // Store color array for later correlation
                    if (value.includes(';')) {
                        filamentColorArray.push(...value.split(';').map(c => c.trim()));
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const colors = JSON.parse(value);
                            if (Array.isArray(colors)) {
                                filamentColorArray.push(...colors);
                            }
                        } catch {
                            // Ignore parse error
                        }
                    }
                    break;
                case 'printer_model':
                    fileMeta.printerModel = value;
                    break;
                // Add other config keys if needed (e.g., layer_height, nozzle_diameter)
            }
        }
    }

    /**
     * Parses additional metadata lines (typically outside specific blocks).
     * @param line The comment line.
     * @param fileMeta The SlicerFileMeta object.
     * @param slicerMeta The SlicerMeta object.
     * @param filamentUsedMMArray Array to store filament usage in mm.
     * @param filamentUsedGArray Array to store filament usage in g.
     */
    private static parseAdditionalData(
        line: string,
        fileMeta: SlicerFileMeta,
        slicerMeta: SlicerMeta,
        filamentUsedMMArray: number[],
        filamentUsedGArray: number[]
    ): void {
        const cleanedLine = line.replace(/^;\s*/, '').trim();
        const equalsIndex = cleanedLine.indexOf('=');

        // Check for ETA line first (doesn't always follow key=value)
        if (cleanedLine.includes('estimated printing time') || cleanedLine.includes('model printing time')) {
            slicerMeta.setEta(cleanedLine); // Use the dedicated method in SlicerMeta
            return; // Don't process further as key=value
        }

        // Process standard key = value lines
        if (equalsIndex > -1) {
            const key = cleanedLine.substring(0, equalsIndex).trim();
            const value = cleanedLine.substring(equalsIndex + 1).trim();

            switch (key) {
                case 'filament used [mm]':
                    // Parse and store as array for later correlation
                    if (value.includes(',')) {
                        // Comma-separated format: "17419.29, 0.00, 0.00, 0.00"
                        filamentUsedMMArray.push(...value.split(',')
                            .map(v => ParserHelper.parseFloatOrDefault(v.trim())));
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const values = JSON.parse(value);
                            if (Array.isArray(values)) {
                                filamentUsedMMArray.push(...values.map((v: any) =>
                                    ParserHelper.parseFloatOrDefault(v)));
                            } else {
                                filamentUsedMMArray.push(ParserHelper.parseFloatOrDefault(value));
                            }
                        } catch {
                            filamentUsedMMArray.push(ParserHelper.parseFloatOrDefault(value));
                        }
                    } else {
                        filamentUsedMMArray.push(ParserHelper.parseFloatOrDefault(value));
                    }
                    // Still set total for backward compatibility
                    fileMeta.filamentUsedMM = filamentUsedMMArray.reduce((sum, val) => sum + val, 0);
                    break;
                case 'filament used [g]':
                    // Parse and store as array for later correlation
                    if (value.includes(',')) {
                        // Comma-separated format: "51.95, 0.00, 0.00, 0.00"
                        filamentUsedGArray.push(...value.split(',')
                            .map(v => ParserHelper.parseFloatOrDefault(v.trim())));
                    } else if (value.startsWith('[') && value.endsWith(']')) {
                        try {
                            const values = JSON.parse(value);
                            if (Array.isArray(values)) {
                                filamentUsedGArray.push(...values.map((v: any) =>
                                    ParserHelper.parseFloatOrDefault(v)));
                            } else {
                                filamentUsedGArray.push(ParserHelper.parseFloatOrDefault(value));
                            }
                        } catch {
                            filamentUsedGArray.push(ParserHelper.parseFloatOrDefault(value));
                        }
                    } else {
                        filamentUsedGArray.push(ParserHelper.parseFloatOrDefault(value));
                    }
                    // Still set total for backward compatibility
                    fileMeta.filamentUsedG = filamentUsedGArray.reduce((sum, val) => sum + val, 0);
                    break;
                // Add other relevant keys found outside blocks
            }
        }
    }

    /**
     * Processes the accumulated base64 thumbnail data.
     * Currently just stores it in fileMeta.
     * @param base64Data The full base64 encoded string.
     * @param fileMeta The SlicerFileMeta object.
     */
    private static processThumbnailData(base64Data: string, fileMeta: SlicerFileMeta): void {
        if (base64Data && base64Data.length > 0) {
            if (/^[A-Za-z0-9+/]*=?=?$/.test(base64Data)) {
                fileMeta.thumbnail = `data:image/png;base64,${base64Data}`;
            } else {
                console.warn("Collected thumbnail data does not appear to be valid Base64.");
                fileMeta.thumbnail = null;
            }
        } else {
            fileMeta.thumbnail = null;
        }
    }
}