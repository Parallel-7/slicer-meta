import * as fs from 'fs';
import { SlicerMeta } from '../../SlicerMeta';
import { SlicerFileMeta } from '../../SlicerFileMeta';
import { SlicerType } from '../../SlicerType';

interface FlashPrintParseResult {
    slicerMeta: SlicerMeta;
    fileMeta: SlicerFileMeta;
}

export class FlashPrintParser {

    /**
     * Parses a G-code file generated by FlashPrint from a file path.
     * @param filePath Path to the G-code file.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     * @throws Error if the file cannot be read.
     */
    public static parse(filePath: string): FlashPrintParseResult {
        try {
            const fileContent = fs.readFileSync(filePath, 'utf-8');
            return FlashPrintParser.parseContent(fileContent);
        } catch (error) {
            console.error(`Error reading or parsing FlashPrint file ${filePath}:`, error);
            throw new Error(`Failed to read or parse FlashPrint file: ${filePath}`);
        }
    }

    /**
     * Parses G-code content generated by FlashPrint from a string or Buffer.
     * @param content The G-code content as a string or Buffer.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    public static parseFromContent(content: string | Buffer): FlashPrintParseResult {
        // Ensure content is a string for line splitting
        const contentString = Buffer.isBuffer(content) ? content.toString('utf-8') : content;
        return FlashPrintParser.parseContent(contentString);
    }

    /**
     * Internal method to parse G-code content string.
     * @param contentString The G-code content as a string.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    private static parseContent(contentString: string): FlashPrintParseResult {
        const slicerMeta = new SlicerMeta();
        const fileMeta = new SlicerFileMeta();
        fileMeta.sliceSoft = SlicerType.FlashPrint; // Set slicer type early

        const lines = contentString.split(/\r?\n/); // Split into lines

        for (const rawLine of lines) {
            const line = rawLine.trim();

            // Stop parsing header comments when a non-comment line is encountered
            if (!line.startsWith(';')) {
                break;
            }

            // Check for the slicer generator line
            if (line.startsWith(';generated by')) {
                slicerMeta.fromGeneratedByString(SlicerType.FlashPrint, line);
                continue; // Move to the next line
            }

            // Parse specific config lines
            FlashPrintParser.parseConfigLine(line, fileMeta);
        }

        // FlashPrint doesn't include ETA or filament usage

        return { slicerMeta, fileMeta };
    }

    /**
     * Parses a specific configuration line from the FlashPrint G-code header.
     * @param line The comment line to parse.
     * @param fileMeta The SlicerFileMeta object to populate.
     */
    private static parseConfigLine(line: string, fileMeta: SlicerFileMeta): void {
        // Remove leading semicolon and split by the first colon
        const parts = line.substring(1).trim().split(':', 2); // Split into max 2 parts
        if (parts.length < 2) return; // Needs key: value format

        const name = parts[0].trim();
        const value = parts[1].trim();

        switch (name) {
            case 'machine_type':
                fileMeta.printerModel = value;
                break;
            case 'right_extruder_material': // todo this will need an eventual refactor to handle multi-material printers (AD5X)
            case 'left_extruder_material':  // todo and if FlashForge makes a new IDEX printer
            case 'material':
                // Only set if not already set, or prioritize 'right' maybe?
                if (fileMeta.filamentType === "Unknown" || name === 'right_extruder_material') {
                    fileMeta.filamentType = value;
                }
                break;
            // Add other relevant FlashPrint keys here if discovered
        }
    }
}