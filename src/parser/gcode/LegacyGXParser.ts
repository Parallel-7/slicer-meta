import * as fs from 'fs';
import { SlicerMeta } from '../../SlicerMeta';
import { SlicerFileMeta } from '../../SlicerFileMeta';
import { SlicerType } from '../../SlicerType';
import { ParserHelper } from '../ParserHelper';

interface LegacyGXParseResult {
    slicerMeta: SlicerMeta;
    fileMeta: SlicerFileMeta;
}

export class LegacyGXParser {
    /**
     * Parses a legacy .gx file from a file path.
     * @param filePath Path to the .gx file.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     * @throws Error if the file cannot be read.
     */
    public static parse(filePath: string): LegacyGXParseResult {
        try {
            const fileBuffer = fs.readFileSync(filePath);
            return LegacyGXParser.parseFromContent(fileBuffer);
        } catch (error) {
            console.error(`Error reading or parsing Legacy GX file ${filePath}:`, error);
            throw new Error(`Failed to read or parse Legacy GX file: ${filePath}`);
        }
    }

    /**
     * Parses a legacy GX content from a Buffer.
     * @param content The GX content as a Buffer.
     * @returns An object containing SlicerMeta and SlicerFileMeta.
     */
    public static parseFromContent(content: Buffer | string): LegacyGXParseResult {
        const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content);
        const slicerMeta = new SlicerMeta();
        const fileMeta = new SlicerFileMeta();
        fileMeta.sliceSoft = SlicerType.LegacyGX;

        try {
            // Extract the PNG thumbnail
            LegacyGXParser.extractThumbnail(buffer, fileMeta);

            try {
                const headerInfo = LegacyGXParser.findHeaderInformation(buffer);
                if (headerInfo) {
                    console.log(`Found header info in binary search: ${headerInfo}`);
                    slicerMeta.fromGeneratedByString(SlicerType.LegacyGX, headerInfo);
                }
            } catch (headerError) {
                console.warn("Error searching for header in binary data:", headerError);
            }
            

            const gcode = LegacyGXParser.extractGcodeContent(buffer);
            LegacyGXParser.parseGcodeContent(gcode, slicerMeta, fileMeta);
            
            return { slicerMeta, fileMeta };
        } catch (error) {
            console.error("Error parsing Legacy GX content:", error);
            throw new Error(`Failed to parse Legacy GX content: ${error}`);
        }
    }
    
    /**
     * Searches for the header information in a binary GX file.
     * @param buffer The GX file buffer.
     * @returns The extracted header information or null if not found.
     */
    private static findHeaderInformation(buffer: Buffer): string | null {
        try {

            const fullContent = buffer.toString('latin1');

            const generatedByMatch = fullContent.match(/; generated by.+on.+at.+/);
            if (generatedByMatch) { return generatedByMatch[0]; }

            const simpleMatch = fullContent.match(/generated by [\w\s-]+ [\d.]+/);
            if (simpleMatch) { return simpleMatch[0]; }
            
            return null;
        } catch (error) {
            console.error("Error searching for header information:", error);
            return null;
        }
    }

    /**
     * Extracts the thumbnail image from the binary GX file.
     * @param buffer The GX file buffer.
     * @param fileMeta The SlicerFileMeta to populate with the thumbnail.
     */
    private static extractThumbnail(buffer: Buffer, fileMeta: SlicerFileMeta): void {
        try {
            const bitmapStart = 58;
            const gcodeStart = 14512;
            
            if (buffer.length >= gcodeStart) {
                const bitmapData = buffer.slice(bitmapStart, gcodeStart);
                const base64Data = bitmapData.toString('base64');
                fileMeta.thumbnail = `data:image/png;base64,${base64Data}`;
            } else {
                console.warn("Buffer too short to contain thumbnail");
                fileMeta.thumbnail = null;
            }
        } catch (error) {
            console.error("Error extracting thumbnail:", error);
            fileMeta.thumbnail = null;
        }
    }

    /**
     * Extracts the G-code content from the binary GX file.
     * @param buffer The GX file buffer.
     * @returns The G-code content as a string.
     */
    private static extractGcodeContent(buffer: Buffer): string {
        try {
            const gcodeStart = 14512;
            
            if (buffer.length > gcodeStart) {
                const gcodeBuffer = buffer.slice(gcodeStart);
                const gcode = gcodeBuffer.toString('utf-8', 0, gcodeBuffer.length);
                if (!gcode.includes('; generated by')) {
                    const rawContent = buffer.toString('utf-8');
                    const generatorLineMatch = rawContent.match(/; generated by [\s\S]+?\r?\n/);
                    if (generatorLineMatch) {
                        return `; HEADER_BLOCK_START\n${generatorLineMatch[0]}; HEADER_BLOCK_END\n` + gcode;
                    }
                }
                return gcode;
            } else {
                console.warn("Buffer too short to contain G-code content");
                return "";
            }
        } catch (error) {
            console.error("Error extracting G-code content:", error);
            return "";
        }
    }

    /**
     * Parses the G-code content to extract metadata.
     * @param gcodeContent The G-code content as a string.
     * @param slicerMeta The SlicerMeta object to populate.
     * @param fileMeta The SlicerFileMeta object to populate.
     */
    private static parseGcodeContent(gcodeContent: string, slicerMeta: SlicerMeta, fileMeta: SlicerFileMeta): void {
        slicerMeta.slicer = SlicerType.LegacyGX;
        
        const lines = gcodeContent.split(/\r?\n/);
        let inHeaderBlock = false;

        for (const line of lines) {
            const trimmedLine = line.trim();
            
            // Block delimiters
            if (trimmedLine.startsWith('; HEADER_BLOCK_START')) { inHeaderBlock = true; continue; }
            if (trimmedLine.startsWith('; HEADER_BLOCK_END')) { inHeaderBlock = false; continue; }
            
            // Process header block information
            if (inHeaderBlock) {
                if (trimmedLine.startsWith('; generated by')) { 
                    slicerMeta.fromGeneratedByString(SlicerType.LegacyGX, trimmedLine); 
                }
            }
            
            // Process ETA (estimated printing time) - may appear anywhere in the file
            if (trimmedLine.startsWith('; estimated printing time')) {
                slicerMeta.setEta(trimmedLine);
            }
            
            // Process other metadata lines
            if (trimmedLine.startsWith('; filament used [mm]')) {
                const match = trimmedLine.match(/; filament used \[mm\] = ([\d.]+)/);
                if (match) {
                    fileMeta.filamentUsedMM = ParserHelper.parseFloatOrDefault(match[1]);
                }
            } 
            else if (trimmedLine.startsWith('; filament used [g]')) {
                const match = trimmedLine.match(/; filament used \[g\] = ([\d.]+)/);
                if (match) {
                    fileMeta.filamentUsedG = ParserHelper.parseFloatOrDefault(match[1]);
                }
            }
            // Filament type detection
            else if (trimmedLine.startsWith(';right_extruder_material:')) {
                const match = trimmedLine.match(/;right_extruder_material: (\w+)/);
                if (match) {
                    fileMeta.filamentType = match[1];
                }
            }
            else if (trimmedLine.startsWith('; default_filament_profile =') || trimmedLine.startsWith('default_filament_profile =')) {
                const match = trimmedLine.match(/default_filament_profile = "([^"]+)/);
                if (match) {
                    // Extract just the material type (e.g., "PLA" from "Flashforge Generic PLA")
                    const fullType = match[1];
                    const parts = fullType.split(' ');
                    const materialType = parts[parts.length - 1]; // Get the last word which is likely the material type
                    fileMeta.filamentType = materialType || fullType; // Fallback to full type if splitting fails
                }
            }
            // Printer model detection
            else if (trimmedLine.startsWith('; printer_model =') || trimmedLine.startsWith('printer_model =')) {
                const match = trimmedLine.match(/printer_model = (.+)$/);
                if (match) {
                    fileMeta.printerModel = match[1].trim();
                }
            }
        }
    }
}
